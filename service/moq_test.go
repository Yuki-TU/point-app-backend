// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service

import (
	"context"
	"github.com/hack-31/point-app-backend/domain/model"
	"github.com/hack-31/point-app-backend/repository"
	"sync"
	"time"
)

// UserRepoMock is a mock implementation of domain.UserRepo.
//
//	func TestSomethingThatUsesUserRepo(t *testing.T) {
//
//		// make and configure a mocked domain.UserRepo
//		mockedUserRepo := &UserRepoMock{
//			FindUserByEmailFunc: func(ctx context.Context, db repository.Queryer, e *string) (model.User, error) {
//				panic("mock out the FindUserByEmail method")
//			},
//			FindUsersFunc: func(ctx context.Context, db repository.Queryer) (model.Users, error) {
//				panic("mock out the FindUsers method")
//			},
//			RegisterUserFunc: func(ctx context.Context, db repository.Execer, u *model.User) error {
//				panic("mock out the RegisterUser method")
//			},
//			UpdateAccountFunc: func(ctx context.Context, db repository.Execer, email *string, familyName *string, familyNameKana *string, firstName *string, firstNameKana *string) error {
//				panic("mock out the UpdateAccount method")
//			},
//			UpdatePasswordFunc: func(ctx context.Context, db repository.Execer, email *string, pass *string) error {
//				panic("mock out the UpdatePassword method")
//			},
//		}
//
//		// use mockedUserRepo in code that requires domain.UserRepo
//		// and then make assertions.
//
//	}
type UserRepoMock struct {
	// FindUserByEmailFunc mocks the FindUserByEmail method.
	FindUserByEmailFunc func(ctx context.Context, db repository.Queryer, e *string) (model.User, error)

	// FindUsersFunc mocks the FindUsers method.
	FindUsersFunc func(ctx context.Context, db repository.Queryer) (model.Users, error)

	// RegisterUserFunc mocks the RegisterUser method.
	RegisterUserFunc func(ctx context.Context, db repository.Execer, u *model.User) error

	// UpdateAccountFunc mocks the UpdateAccount method.
	UpdateAccountFunc func(ctx context.Context, db repository.Execer, email *string, familyName *string, familyNameKana *string, firstName *string, firstNameKana *string) error

	// UpdatePasswordFunc mocks the UpdatePassword method.
	UpdatePasswordFunc func(ctx context.Context, db repository.Execer, email *string, pass *string) error

	// calls tracks calls to the methods.
	calls struct {
		// FindUserByEmail holds details about calls to the FindUserByEmail method.
		FindUserByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Queryer
			// E is the e argument value.
			E *string
		}
		// FindUsers holds details about calls to the FindUsers method.
		FindUsers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Queryer
		}
		// RegisterUser holds details about calls to the RegisterUser method.
		RegisterUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Execer
			// U is the u argument value.
			U *model.User
		}
		// UpdateAccount holds details about calls to the UpdateAccount method.
		UpdateAccount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Execer
			// Email is the email argument value.
			Email *string
			// FamilyName is the familyName argument value.
			FamilyName *string
			// FamilyNameKana is the familyNameKana argument value.
			FamilyNameKana *string
			// FirstName is the firstName argument value.
			FirstName *string
			// FirstNameKana is the firstNameKana argument value.
			FirstNameKana *string
		}
		// UpdatePassword holds details about calls to the UpdatePassword method.
		UpdatePassword []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Execer
			// Email is the email argument value.
			Email *string
			// Pass is the pass argument value.
			Pass *string
		}
	}
	lockFindUserByEmail sync.RWMutex
	lockFindUsers       sync.RWMutex
	lockRegisterUser    sync.RWMutex
	lockUpdateAccount   sync.RWMutex
	lockUpdatePassword  sync.RWMutex
}

// FindUserByEmail calls FindUserByEmailFunc.
func (mock *UserRepoMock) FindUserByEmail(ctx context.Context, db repository.Queryer, e *string) (model.User, error) {
	if mock.FindUserByEmailFunc == nil {
		panic("UserRepoMock.FindUserByEmailFunc: method is nil but UserRepo.FindUserByEmail was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  repository.Queryer
		E   *string
	}{
		Ctx: ctx,
		Db:  db,
		E:   e,
	}
	mock.lockFindUserByEmail.Lock()
	mock.calls.FindUserByEmail = append(mock.calls.FindUserByEmail, callInfo)
	mock.lockFindUserByEmail.Unlock()
	return mock.FindUserByEmailFunc(ctx, db, e)
}

// FindUserByEmailCalls gets all the calls that were made to FindUserByEmail.
// Check the length with:
//
//	len(mockedUserRepo.FindUserByEmailCalls())
func (mock *UserRepoMock) FindUserByEmailCalls() []struct {
	Ctx context.Context
	Db  repository.Queryer
	E   *string
} {
	var calls []struct {
		Ctx context.Context
		Db  repository.Queryer
		E   *string
	}
	mock.lockFindUserByEmail.RLock()
	calls = mock.calls.FindUserByEmail
	mock.lockFindUserByEmail.RUnlock()
	return calls
}

// FindUsers calls FindUsersFunc.
func (mock *UserRepoMock) FindUsers(ctx context.Context, db repository.Queryer) (model.Users, error) {
	if mock.FindUsersFunc == nil {
		panic("UserRepoMock.FindUsersFunc: method is nil but UserRepo.FindUsers was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  repository.Queryer
	}{
		Ctx: ctx,
		Db:  db,
	}
	mock.lockFindUsers.Lock()
	mock.calls.FindUsers = append(mock.calls.FindUsers, callInfo)
	mock.lockFindUsers.Unlock()
	return mock.FindUsersFunc(ctx, db)
}

// FindUsersCalls gets all the calls that were made to FindUsers.
// Check the length with:
//
//	len(mockedUserRepo.FindUsersCalls())
func (mock *UserRepoMock) FindUsersCalls() []struct {
	Ctx context.Context
	Db  repository.Queryer
} {
	var calls []struct {
		Ctx context.Context
		Db  repository.Queryer
	}
	mock.lockFindUsers.RLock()
	calls = mock.calls.FindUsers
	mock.lockFindUsers.RUnlock()
	return calls
}

// RegisterUser calls RegisterUserFunc.
func (mock *UserRepoMock) RegisterUser(ctx context.Context, db repository.Execer, u *model.User) error {
	if mock.RegisterUserFunc == nil {
		panic("UserRepoMock.RegisterUserFunc: method is nil but UserRepo.RegisterUser was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  repository.Execer
		U   *model.User
	}{
		Ctx: ctx,
		Db:  db,
		U:   u,
	}
	mock.lockRegisterUser.Lock()
	mock.calls.RegisterUser = append(mock.calls.RegisterUser, callInfo)
	mock.lockRegisterUser.Unlock()
	return mock.RegisterUserFunc(ctx, db, u)
}

// RegisterUserCalls gets all the calls that were made to RegisterUser.
// Check the length with:
//
//	len(mockedUserRepo.RegisterUserCalls())
func (mock *UserRepoMock) RegisterUserCalls() []struct {
	Ctx context.Context
	Db  repository.Execer
	U   *model.User
} {
	var calls []struct {
		Ctx context.Context
		Db  repository.Execer
		U   *model.User
	}
	mock.lockRegisterUser.RLock()
	calls = mock.calls.RegisterUser
	mock.lockRegisterUser.RUnlock()
	return calls
}

// UpdateAccount calls UpdateAccountFunc.
func (mock *UserRepoMock) UpdateAccount(ctx context.Context, db repository.Execer, email *string, familyName *string, familyNameKana *string, firstName *string, firstNameKana *string) error {
	if mock.UpdateAccountFunc == nil {
		panic("UserRepoMock.UpdateAccountFunc: method is nil but UserRepo.UpdateAccount was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Db             repository.Execer
		Email          *string
		FamilyName     *string
		FamilyNameKana *string
		FirstName      *string
		FirstNameKana  *string
	}{
		Ctx:            ctx,
		Db:             db,
		Email:          email,
		FamilyName:     familyName,
		FamilyNameKana: familyNameKana,
		FirstName:      firstName,
		FirstNameKana:  firstNameKana,
	}
	mock.lockUpdateAccount.Lock()
	mock.calls.UpdateAccount = append(mock.calls.UpdateAccount, callInfo)
	mock.lockUpdateAccount.Unlock()
	return mock.UpdateAccountFunc(ctx, db, email, familyName, familyNameKana, firstName, firstNameKana)
}

// UpdateAccountCalls gets all the calls that were made to UpdateAccount.
// Check the length with:
//
//	len(mockedUserRepo.UpdateAccountCalls())
func (mock *UserRepoMock) UpdateAccountCalls() []struct {
	Ctx            context.Context
	Db             repository.Execer
	Email          *string
	FamilyName     *string
	FamilyNameKana *string
	FirstName      *string
	FirstNameKana  *string
} {
	var calls []struct {
		Ctx            context.Context
		Db             repository.Execer
		Email          *string
		FamilyName     *string
		FamilyNameKana *string
		FirstName      *string
		FirstNameKana  *string
	}
	mock.lockUpdateAccount.RLock()
	calls = mock.calls.UpdateAccount
	mock.lockUpdateAccount.RUnlock()
	return calls
}

// UpdatePassword calls UpdatePasswordFunc.
func (mock *UserRepoMock) UpdatePassword(ctx context.Context, db repository.Execer, email *string, pass *string) error {
	if mock.UpdatePasswordFunc == nil {
		panic("UserRepoMock.UpdatePasswordFunc: method is nil but UserRepo.UpdatePassword was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Db    repository.Execer
		Email *string
		Pass  *string
	}{
		Ctx:   ctx,
		Db:    db,
		Email: email,
		Pass:  pass,
	}
	mock.lockUpdatePassword.Lock()
	mock.calls.UpdatePassword = append(mock.calls.UpdatePassword, callInfo)
	mock.lockUpdatePassword.Unlock()
	return mock.UpdatePasswordFunc(ctx, db, email, pass)
}

// UpdatePasswordCalls gets all the calls that were made to UpdatePassword.
// Check the length with:
//
//	len(mockedUserRepo.UpdatePasswordCalls())
func (mock *UserRepoMock) UpdatePasswordCalls() []struct {
	Ctx   context.Context
	Db    repository.Execer
	Email *string
	Pass  *string
} {
	var calls []struct {
		Ctx   context.Context
		Db    repository.Execer
		Email *string
		Pass  *string
	}
	mock.lockUpdatePassword.RLock()
	calls = mock.calls.UpdatePassword
	mock.lockUpdatePassword.RUnlock()
	return calls
}

// PointRepoMock is a mock implementation of domain.PointRepo.
//
//	func TestSomethingThatUsesPointRepo(t *testing.T) {
//
//		// make and configure a mocked domain.PointRepo
//		mockedPointRepo := &PointRepoMock{
//			RegisterPointTransactionFunc: func(ctx context.Context, db repository.Execer, fromUserID model.UserID, toUserId model.UserID, sendPoint int) error {
//				panic("mock out the RegisterPointTransaction method")
//			},
//			UpdateSendablePointFunc: func(ctx context.Context, db repository.Execer, fromUserID model.UserID, sendPoint int) error {
//				panic("mock out the UpdateSendablePoint method")
//			},
//		}
//
//		// use mockedPointRepo in code that requires domain.PointRepo
//		// and then make assertions.
//
//	}
type PointRepoMock struct {
	// RegisterPointTransactionFunc mocks the RegisterPointTransaction method.
	RegisterPointTransactionFunc func(ctx context.Context, db repository.Execer, fromUserID model.UserID, toUserId model.UserID, sendPoint int) error

	// UpdateSendablePointFunc mocks the UpdateSendablePoint method.
	UpdateSendablePointFunc func(ctx context.Context, db repository.Execer, fromUserID model.UserID, sendPoint int) error

	// calls tracks calls to the methods.
	calls struct {
		// RegisterPointTransaction holds details about calls to the RegisterPointTransaction method.
		RegisterPointTransaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Execer
			// FromUserID is the fromUserID argument value.
			FromUserID model.UserID
			// ToUserId is the toUserId argument value.
			ToUserId model.UserID
			// SendPoint is the sendPoint argument value.
			SendPoint int
		}
		// UpdateSendablePoint holds details about calls to the UpdateSendablePoint method.
		UpdateSendablePoint []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Execer
			// FromUserID is the fromUserID argument value.
			FromUserID model.UserID
			// SendPoint is the sendPoint argument value.
			SendPoint int
		}
	}
	lockRegisterPointTransaction sync.RWMutex
	lockUpdateSendablePoint      sync.RWMutex
}

// RegisterPointTransaction calls RegisterPointTransactionFunc.
func (mock *PointRepoMock) RegisterPointTransaction(ctx context.Context, db repository.Execer, fromUserID model.UserID, toUserId model.UserID, sendPoint int) error {
	if mock.RegisterPointTransactionFunc == nil {
		panic("PointRepoMock.RegisterPointTransactionFunc: method is nil but PointRepo.RegisterPointTransaction was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Db         repository.Execer
		FromUserID model.UserID
		ToUserId   model.UserID
		SendPoint  int
	}{
		Ctx:        ctx,
		Db:         db,
		FromUserID: fromUserID,
		ToUserId:   toUserId,
		SendPoint:  sendPoint,
	}
	mock.lockRegisterPointTransaction.Lock()
	mock.calls.RegisterPointTransaction = append(mock.calls.RegisterPointTransaction, callInfo)
	mock.lockRegisterPointTransaction.Unlock()
	return mock.RegisterPointTransactionFunc(ctx, db, fromUserID, toUserId, sendPoint)
}

// RegisterPointTransactionCalls gets all the calls that were made to RegisterPointTransaction.
// Check the length with:
//
//	len(mockedPointRepo.RegisterPointTransactionCalls())
func (mock *PointRepoMock) RegisterPointTransactionCalls() []struct {
	Ctx        context.Context
	Db         repository.Execer
	FromUserID model.UserID
	ToUserId   model.UserID
	SendPoint  int
} {
	var calls []struct {
		Ctx        context.Context
		Db         repository.Execer
		FromUserID model.UserID
		ToUserId   model.UserID
		SendPoint  int
	}
	mock.lockRegisterPointTransaction.RLock()
	calls = mock.calls.RegisterPointTransaction
	mock.lockRegisterPointTransaction.RUnlock()
	return calls
}

// UpdateSendablePoint calls UpdateSendablePointFunc.
func (mock *PointRepoMock) UpdateSendablePoint(ctx context.Context, db repository.Execer, fromUserID model.UserID, sendPoint int) error {
	if mock.UpdateSendablePointFunc == nil {
		panic("PointRepoMock.UpdateSendablePointFunc: method is nil but PointRepo.UpdateSendablePoint was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Db         repository.Execer
		FromUserID model.UserID
		SendPoint  int
	}{
		Ctx:        ctx,
		Db:         db,
		FromUserID: fromUserID,
		SendPoint:  sendPoint,
	}
	mock.lockUpdateSendablePoint.Lock()
	mock.calls.UpdateSendablePoint = append(mock.calls.UpdateSendablePoint, callInfo)
	mock.lockUpdateSendablePoint.Unlock()
	return mock.UpdateSendablePointFunc(ctx, db, fromUserID, sendPoint)
}

// UpdateSendablePointCalls gets all the calls that were made to UpdateSendablePoint.
// Check the length with:
//
//	len(mockedPointRepo.UpdateSendablePointCalls())
func (mock *PointRepoMock) UpdateSendablePointCalls() []struct {
	Ctx        context.Context
	Db         repository.Execer
	FromUserID model.UserID
	SendPoint  int
} {
	var calls []struct {
		Ctx        context.Context
		Db         repository.Execer
		FromUserID model.UserID
		SendPoint  int
	}
	mock.lockUpdateSendablePoint.RLock()
	calls = mock.calls.UpdateSendablePoint
	mock.lockUpdateSendablePoint.RUnlock()
	return calls
}

// TokenGeneratorMock is a mock implementation of domain.TokenGenerator.
//
//	func TestSomethingThatUsesTokenGenerator(t *testing.T) {
//
//		// make and configure a mocked domain.TokenGenerator
//		mockedTokenGenerator := &TokenGeneratorMock{
//			GenerateTokenFunc: func(ctx context.Context, u model.User) ([]byte, error) {
//				panic("mock out the GenerateToken method")
//			},
//		}
//
//		// use mockedTokenGenerator in code that requires domain.TokenGenerator
//		// and then make assertions.
//
//	}
type TokenGeneratorMock struct {
	// GenerateTokenFunc mocks the GenerateToken method.
	GenerateTokenFunc func(ctx context.Context, u model.User) ([]byte, error)

	// calls tracks calls to the methods.
	calls struct {
		// GenerateToken holds details about calls to the GenerateToken method.
		GenerateToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// U is the u argument value.
			U model.User
		}
	}
	lockGenerateToken sync.RWMutex
}

// GenerateToken calls GenerateTokenFunc.
func (mock *TokenGeneratorMock) GenerateToken(ctx context.Context, u model.User) ([]byte, error) {
	if mock.GenerateTokenFunc == nil {
		panic("TokenGeneratorMock.GenerateTokenFunc: method is nil but TokenGenerator.GenerateToken was just called")
	}
	callInfo := struct {
		Ctx context.Context
		U   model.User
	}{
		Ctx: ctx,
		U:   u,
	}
	mock.lockGenerateToken.Lock()
	mock.calls.GenerateToken = append(mock.calls.GenerateToken, callInfo)
	mock.lockGenerateToken.Unlock()
	return mock.GenerateTokenFunc(ctx, u)
}

// GenerateTokenCalls gets all the calls that were made to GenerateToken.
// Check the length with:
//
//	len(mockedTokenGenerator.GenerateTokenCalls())
func (mock *TokenGeneratorMock) GenerateTokenCalls() []struct {
	Ctx context.Context
	U   model.User
} {
	var calls []struct {
		Ctx context.Context
		U   model.User
	}
	mock.lockGenerateToken.RLock()
	calls = mock.calls.GenerateToken
	mock.lockGenerateToken.RUnlock()
	return calls
}

// CacheMock is a mock implementation of domain.Cache.
//
//	func TestSomethingThatUsesCache(t *testing.T) {
//
//		// make and configure a mocked domain.Cache
//		mockedCache := &CacheMock{
//			DeleteFunc: func(ctx context.Context, key string) error {
//				panic("mock out the Delete method")
//			},
//			LoadFunc: func(ctx context.Context, key string) (string, error) {
//				panic("mock out the Load method")
//			},
//			SaveFunc: func(ctx context.Context, key string, value string, minute time.Duration) error {
//				panic("mock out the Save method")
//			},
//		}
//
//		// use mockedCache in code that requires domain.Cache
//		// and then make assertions.
//
//	}
type CacheMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, key string) error

	// LoadFunc mocks the Load method.
	LoadFunc func(ctx context.Context, key string) (string, error)

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, key string, value string, minute time.Duration) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Load holds details about calls to the Load method.
		Load []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value string
			// Minute is the minute argument value.
			Minute time.Duration
		}
	}
	lockDelete sync.RWMutex
	lockLoad   sync.RWMutex
	lockSave   sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *CacheMock) Delete(ctx context.Context, key string) error {
	if mock.DeleteFunc == nil {
		panic("CacheMock.DeleteFunc: method is nil but Cache.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, key)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedCache.DeleteCalls())
func (mock *CacheMock) DeleteCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Load calls LoadFunc.
func (mock *CacheMock) Load(ctx context.Context, key string) (string, error) {
	if mock.LoadFunc == nil {
		panic("CacheMock.LoadFunc: method is nil but Cache.Load was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockLoad.Lock()
	mock.calls.Load = append(mock.calls.Load, callInfo)
	mock.lockLoad.Unlock()
	return mock.LoadFunc(ctx, key)
}

// LoadCalls gets all the calls that were made to Load.
// Check the length with:
//
//	len(mockedCache.LoadCalls())
func (mock *CacheMock) LoadCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockLoad.RLock()
	calls = mock.calls.Load
	mock.lockLoad.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *CacheMock) Save(ctx context.Context, key string, value string, minute time.Duration) error {
	if mock.SaveFunc == nil {
		panic("CacheMock.SaveFunc: method is nil but Cache.Save was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Value  string
		Minute time.Duration
	}{
		Ctx:    ctx,
		Key:    key,
		Value:  value,
		Minute: minute,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, key, value, minute)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedCache.SaveCalls())
func (mock *CacheMock) SaveCalls() []struct {
	Ctx    context.Context
	Key    string
	Value  string
	Minute time.Duration
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Value  string
		Minute time.Duration
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

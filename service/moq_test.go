// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service

import (
	"context"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/hack-31/point-app-backend/domain/model"
	"github.com/hack-31/point-app-backend/repository"
	customentities "github.com/hack-31/point-app-backend/repository/custom_entities"
	"github.com/hack-31/point-app-backend/repository/entities"
)

// CacheMock is a mock implementation of domain.Cache.
//
//	func TestSomethingThatUsesCache(t *testing.T) {
//
//		// make and configure a mocked domain.Cache
//		mockedCache := &CacheMock{
//			DeleteFunc: func(ctx context.Context, key string) error {
//				panic("mock out the Delete method")
//			},
//			ExpireFunc: func(ctx context.Context, key string, minitue time.Duration) error {
//				panic("mock out the Expire method")
//			},
//			LoadFunc: func(ctx context.Context, key string) (string, error) {
//				panic("mock out the Load method")
//			},
//			PublishFunc: func(ctx context.Context, channel string, palyload string) error {
//				panic("mock out the Publish method")
//			},
//			SaveFunc: func(ctx context.Context, key string, value string, minute time.Duration) error {
//				panic("mock out the Save method")
//			},
//			SubscribeFunc: func(ctx *gin.Context, channel string) (<-chan string, error) {
//				panic("mock out the Subscribe method")
//			},
//		}
//
//		// use mockedCache in code that requires domain.Cache
//		// and then make assertions.
//
//	}
type CacheMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, key string) error

	// ExpireFunc mocks the Expire method.
	ExpireFunc func(ctx context.Context, key string, minitue time.Duration) error

	// LoadFunc mocks the Load method.
	LoadFunc func(ctx context.Context, key string) (string, error)

	// PublishFunc mocks the Publish method.
	PublishFunc func(ctx context.Context, channel string, palyload string) error

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, key string, value string, minute time.Duration) error

	// SubscribeFunc mocks the Subscribe method.
	SubscribeFunc func(ctx *gin.Context, channel string) (<-chan string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Expire holds details about calls to the Expire method.
		Expire []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Minitue is the minitue argument value.
			Minitue time.Duration
		}
		// Load holds details about calls to the Load method.
		Load []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Publish holds details about calls to the Publish method.
		Publish []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Channel is the channel argument value.
			Channel string
			// Palyload is the palyload argument value.
			Palyload string
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value string
			// Minute is the minute argument value.
			Minute time.Duration
		}
		// Subscribe holds details about calls to the Subscribe method.
		Subscribe []struct {
			// Ctx is the ctx argument value.
			Ctx *gin.Context
			// Channel is the channel argument value.
			Channel string
		}
	}
	lockDelete    sync.RWMutex
	lockExpire    sync.RWMutex
	lockLoad      sync.RWMutex
	lockPublish   sync.RWMutex
	lockSave      sync.RWMutex
	lockSubscribe sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *CacheMock) Delete(ctx context.Context, key string) error {
	if mock.DeleteFunc == nil {
		panic("CacheMock.DeleteFunc: method is nil but Cache.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, key)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedCache.DeleteCalls())
func (mock *CacheMock) DeleteCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Expire calls ExpireFunc.
func (mock *CacheMock) Expire(ctx context.Context, key string, minitue time.Duration) error {
	if mock.ExpireFunc == nil {
		panic("CacheMock.ExpireFunc: method is nil but Cache.Expire was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Minitue time.Duration
	}{
		Ctx:     ctx,
		Key:     key,
		Minitue: minitue,
	}
	mock.lockExpire.Lock()
	mock.calls.Expire = append(mock.calls.Expire, callInfo)
	mock.lockExpire.Unlock()
	return mock.ExpireFunc(ctx, key, minitue)
}

// ExpireCalls gets all the calls that were made to Expire.
// Check the length with:
//
//	len(mockedCache.ExpireCalls())
func (mock *CacheMock) ExpireCalls() []struct {
	Ctx     context.Context
	Key     string
	Minitue time.Duration
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Minitue time.Duration
	}
	mock.lockExpire.RLock()
	calls = mock.calls.Expire
	mock.lockExpire.RUnlock()
	return calls
}

// Load calls LoadFunc.
func (mock *CacheMock) Load(ctx context.Context, key string) (string, error) {
	if mock.LoadFunc == nil {
		panic("CacheMock.LoadFunc: method is nil but Cache.Load was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockLoad.Lock()
	mock.calls.Load = append(mock.calls.Load, callInfo)
	mock.lockLoad.Unlock()
	return mock.LoadFunc(ctx, key)
}

// LoadCalls gets all the calls that were made to Load.
// Check the length with:
//
//	len(mockedCache.LoadCalls())
func (mock *CacheMock) LoadCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockLoad.RLock()
	calls = mock.calls.Load
	mock.lockLoad.RUnlock()
	return calls
}

// Publish calls PublishFunc.
func (mock *CacheMock) Publish(ctx context.Context, channel string, palyload string) error {
	if mock.PublishFunc == nil {
		panic("CacheMock.PublishFunc: method is nil but Cache.Publish was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Channel  string
		Palyload string
	}{
		Ctx:      ctx,
		Channel:  channel,
		Palyload: palyload,
	}
	mock.lockPublish.Lock()
	mock.calls.Publish = append(mock.calls.Publish, callInfo)
	mock.lockPublish.Unlock()
	return mock.PublishFunc(ctx, channel, palyload)
}

// PublishCalls gets all the calls that were made to Publish.
// Check the length with:
//
//	len(mockedCache.PublishCalls())
func (mock *CacheMock) PublishCalls() []struct {
	Ctx      context.Context
	Channel  string
	Palyload string
} {
	var calls []struct {
		Ctx      context.Context
		Channel  string
		Palyload string
	}
	mock.lockPublish.RLock()
	calls = mock.calls.Publish
	mock.lockPublish.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *CacheMock) Save(ctx context.Context, key string, value string, minute time.Duration) error {
	if mock.SaveFunc == nil {
		panic("CacheMock.SaveFunc: method is nil but Cache.Save was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Value  string
		Minute time.Duration
	}{
		Ctx:    ctx,
		Key:    key,
		Value:  value,
		Minute: minute,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, key, value, minute)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedCache.SaveCalls())
func (mock *CacheMock) SaveCalls() []struct {
	Ctx    context.Context
	Key    string
	Value  string
	Minute time.Duration
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Value  string
		Minute time.Duration
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Subscribe calls SubscribeFunc.
func (mock *CacheMock) Subscribe(ctx *gin.Context, channel string) (<-chan string, error) {
	if mock.SubscribeFunc == nil {
		panic("CacheMock.SubscribeFunc: method is nil but Cache.Subscribe was just called")
	}
	callInfo := struct {
		Ctx     *gin.Context
		Channel string
	}{
		Ctx:     ctx,
		Channel: channel,
	}
	mock.lockSubscribe.Lock()
	mock.calls.Subscribe = append(mock.calls.Subscribe, callInfo)
	mock.lockSubscribe.Unlock()
	return mock.SubscribeFunc(ctx, channel)
}

// SubscribeCalls gets all the calls that were made to Subscribe.
// Check the length with:
//
//	len(mockedCache.SubscribeCalls())
func (mock *CacheMock) SubscribeCalls() []struct {
	Ctx     *gin.Context
	Channel string
} {
	var calls []struct {
		Ctx     *gin.Context
		Channel string
	}
	mock.lockSubscribe.RLock()
	calls = mock.calls.Subscribe
	mock.lockSubscribe.RUnlock()
	return calls
}

// TokenGeneratorMock is a mock implementation of domain.TokenGenerator.
//
//	func TestSomethingThatUsesTokenGenerator(t *testing.T) {
//
//		// make and configure a mocked domain.TokenGenerator
//		mockedTokenGenerator := &TokenGeneratorMock{
//			GenerateTokenFunc: func(ctx context.Context, u entities.User) ([]byte, error) {
//				panic("mock out the GenerateToken method")
//			},
//		}
//
//		// use mockedTokenGenerator in code that requires domain.TokenGenerator
//		// and then make assertions.
//
//	}
type TokenGeneratorMock struct {
	// GenerateTokenFunc mocks the GenerateToken method.
	GenerateTokenFunc func(ctx context.Context, u entities.User) ([]byte, error)

	// calls tracks calls to the methods.
	calls struct {
		// GenerateToken holds details about calls to the GenerateToken method.
		GenerateToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// U is the u argument value.
			U entities.User
		}
	}
	lockGenerateToken sync.RWMutex
}

// GenerateToken calls GenerateTokenFunc.
func (mock *TokenGeneratorMock) GenerateToken(ctx context.Context, u entities.User) ([]byte, error) {
	if mock.GenerateTokenFunc == nil {
		panic("TokenGeneratorMock.GenerateTokenFunc: method is nil but TokenGenerator.GenerateToken was just called")
	}
	callInfo := struct {
		Ctx context.Context
		U   entities.User
	}{
		Ctx: ctx,
		U:   u,
	}
	mock.lockGenerateToken.Lock()
	mock.calls.GenerateToken = append(mock.calls.GenerateToken, callInfo)
	mock.lockGenerateToken.Unlock()
	return mock.GenerateTokenFunc(ctx, u)
}

// GenerateTokenCalls gets all the calls that were made to GenerateToken.
// Check the length with:
//
//	len(mockedTokenGenerator.GenerateTokenCalls())
func (mock *TokenGeneratorMock) GenerateTokenCalls() []struct {
	Ctx context.Context
	U   entities.User
} {
	var calls []struct {
		Ctx context.Context
		U   entities.User
	}
	mock.lockGenerateToken.RLock()
	calls = mock.calls.GenerateToken
	mock.lockGenerateToken.RUnlock()
	return calls
}

// UserRepoMock is a mock implementation of domain.UserRepo.
//
//	func TestSomethingThatUsesUserRepo(t *testing.T) {
//
//		// make and configure a mocked domain.UserRepo
//		mockedUserRepo := &UserRepoMock{
//			DeleteUserByIDFunc: func(ctx context.Context, db repository.Execer, ID model.UserID) (int64, error) {
//				panic("mock out the DeleteUserByID method")
//			},
//			FindUserByEmailFunc: func(ctx context.Context, db repository.Queryer, e string, columns ...string) (entities.User, error) {
//				panic("mock out the FindUserByEmail method")
//			},
//			GetAllFunc: func(ctx context.Context, db repository.Queryer, columns ...string) ([]*entities.User, error) {
//				panic("mock out the GetAll method")
//			},
//			GetAllOrderPointFunc: func(ctx context.Context, db repository.Queryer, param repository.GetAllOrderPointParam) ([]*entities.User, error) {
//				panic("mock out the GetAllOrderPoint method")
//			},
//			GetUserByIDFunc: func(ctx context.Context, db repository.Queryer, ID model.UserID) (entities.User, error) {
//				panic("mock out the GetUserByID method")
//			},
//			GetUsersLimitFunc: func(ctx context.Context, db repository.Queryer, param repository.GetUsersLimitParam) ([]*entities.User, error) {
//				panic("mock out the GetUsersLimit method")
//			},
//			RegisterUserFunc: func(ctx context.Context, db repository.Execer, u *entities.User) error {
//				panic("mock out the RegisterUser method")
//			},
//			UpdateAccountFunc: func(ctx context.Context, db repository.Execer, email *string, familyName *string, familyNameKana *string, firstName *string, firstNameKana *string) error {
//				panic("mock out the UpdateAccount method")
//			},
//			UpdateEmailFunc: func(ctx context.Context, db repository.Execer, userID model.UserID, newEmail string) error {
//				panic("mock out the UpdateEmail method")
//			},
//			UpdatePasswordFunc: func(ctx context.Context, db repository.Execer, email *string, pass *string) error {
//				panic("mock out the UpdatePassword method")
//			},
//		}
//
//		// use mockedUserRepo in code that requires domain.UserRepo
//		// and then make assertions.
//
//	}
type UserRepoMock struct {
	// DeleteUserByIDFunc mocks the DeleteUserByID method.
	DeleteUserByIDFunc func(ctx context.Context, db repository.Execer, ID model.UserID) (int64, error)

	// FindUserByEmailFunc mocks the FindUserByEmail method.
	FindUserByEmailFunc func(ctx context.Context, db repository.Queryer, e string, columns ...string) (entities.User, error)

	// GetAllFunc mocks the GetAll method.
	GetAllFunc func(ctx context.Context, db repository.Queryer, columns ...string) ([]*entities.User, error)

	// GetAllOrderPointFunc mocks the GetAllOrderPoint method.
	GetAllOrderPointFunc func(ctx context.Context, db repository.Queryer, param repository.GetAllWithCursorParam) ([]*entities.User, error)

	// GetUserByIDFunc mocks the GetUserByID method.
	GetUserByIDFunc func(ctx context.Context, db repository.Queryer, ID model.UserID) (entities.User, error)

	// GetUsersLimitFunc mocks the GetUsersLimit method.
	GetUsersLimitFunc func(ctx context.Context, db repository.Queryer, param repository.GetUsersParam) ([]*entities.User, error)

	// RegisterUserFunc mocks the RegisterUser method.
	RegisterUserFunc func(ctx context.Context, db repository.Execer, u *entities.User) error

	// UpdateAccountFunc mocks the UpdateAccount method.
	UpdateAccountFunc func(ctx context.Context, db repository.Execer, email *string, familyName *string, familyNameKana *string, firstName *string, firstNameKana *string) error

	// UpdateEmailFunc mocks the UpdateEmail method.
	UpdateEmailFunc func(ctx context.Context, db repository.Execer, userID model.UserID, newEmail string) error

	// UpdatePasswordFunc mocks the UpdatePassword method.
	UpdatePasswordFunc func(ctx context.Context, db repository.Execer, email *string, pass *string) error

	// calls tracks calls to the methods.
	calls struct {
		// DeleteUserByID holds details about calls to the DeleteUserByID method.
		DeleteUserByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Execer
			// ID is the ID argument value.
			ID model.UserID
		}
		// FindUserByEmail holds details about calls to the FindUserByEmail method.
		FindUserByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Queryer
			// E is the e argument value.
			E string
			// Columns is the columns argument value.
			Columns []string
		}
		// GetAll holds details about calls to the GetAll method.
		GetAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Queryer
			// Columns is the columns argument value.
			Columns []string
		}
		// GetAllOrderPoint holds details about calls to the GetAllOrderPoint method.
		GetAllOrderPoint []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Queryer
			// Param is the param argument value.
			Param repository.GetAllWithCursorParam
		}
		// GetUserByID holds details about calls to the GetUserByID method.
		GetUserByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Queryer
			// ID is the ID argument value.
			ID model.UserID
		}
		// GetUsersLimit holds details about calls to the GetUsersLimit method.
		GetUsersLimit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Queryer
			// Param is the param argument value.
			Param repository.GetUsersParam
		}
		// RegisterUser holds details about calls to the RegisterUser method.
		RegisterUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Execer
			// U is the u argument value.
			U *entities.User
		}
		// UpdateAccount holds details about calls to the UpdateAccount method.
		UpdateAccount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Execer
			// Email is the email argument value.
			Email *string
			// FamilyName is the familyName argument value.
			FamilyName *string
			// FamilyNameKana is the familyNameKana argument value.
			FamilyNameKana *string
			// FirstName is the firstName argument value.
			FirstName *string
			// FirstNameKana is the firstNameKana argument value.
			FirstNameKana *string
		}
		// UpdateEmail holds details about calls to the UpdateEmail method.
		UpdateEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Execer
			// UserID is the userID argument value.
			UserID model.UserID
			// NewEmail is the newEmail argument value.
			NewEmail string
		}
		// UpdatePassword holds details about calls to the UpdatePassword method.
		UpdatePassword []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Execer
			// Email is the email argument value.
			Email *string
			// Pass is the pass argument value.
			Pass *string
		}
	}
	lockDeleteUserByID   sync.RWMutex
	lockFindUserByEmail  sync.RWMutex
	lockGetAll           sync.RWMutex
	lockGetAllOrderPoint sync.RWMutex
	lockGetUserByID      sync.RWMutex
	lockGetUsersLimit    sync.RWMutex
	lockRegisterUser     sync.RWMutex
	lockUpdateAccount    sync.RWMutex
	lockUpdateEmail      sync.RWMutex
	lockUpdatePassword   sync.RWMutex
}

// DeleteUserByID calls DeleteUserByIDFunc.
func (mock *UserRepoMock) DeleteUserByID(ctx context.Context, db repository.Execer, ID model.UserID) (int64, error) {
	if mock.DeleteUserByIDFunc == nil {
		panic("UserRepoMock.DeleteUserByIDFunc: method is nil but UserRepo.DeleteUserByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  repository.Execer
		ID  model.UserID
	}{
		Ctx: ctx,
		Db:  db,
		ID:  ID,
	}
	mock.lockDeleteUserByID.Lock()
	mock.calls.DeleteUserByID = append(mock.calls.DeleteUserByID, callInfo)
	mock.lockDeleteUserByID.Unlock()
	return mock.DeleteUserByIDFunc(ctx, db, ID)
}

// DeleteUserByIDCalls gets all the calls that were made to DeleteUserByID.
// Check the length with:
//
//	len(mockedUserRepo.DeleteUserByIDCalls())
func (mock *UserRepoMock) DeleteUserByIDCalls() []struct {
	Ctx context.Context
	Db  repository.Execer
	ID  model.UserID
} {
	var calls []struct {
		Ctx context.Context
		Db  repository.Execer
		ID  model.UserID
	}
	mock.lockDeleteUserByID.RLock()
	calls = mock.calls.DeleteUserByID
	mock.lockDeleteUserByID.RUnlock()
	return calls
}

// FindUserByEmail calls FindUserByEmailFunc.
func (mock *UserRepoMock) FindUserByEmail(ctx context.Context, db repository.Queryer, e string, columns ...string) (entities.User, error) {
	if mock.FindUserByEmailFunc == nil {
		panic("UserRepoMock.FindUserByEmailFunc: method is nil but UserRepo.FindUserByEmail was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Db      repository.Queryer
		E       string
		Columns []string
	}{
		Ctx:     ctx,
		Db:      db,
		E:       e,
		Columns: columns,
	}
	mock.lockFindUserByEmail.Lock()
	mock.calls.FindUserByEmail = append(mock.calls.FindUserByEmail, callInfo)
	mock.lockFindUserByEmail.Unlock()
	return mock.FindUserByEmailFunc(ctx, db, e, columns...)
}

// FindUserByEmailCalls gets all the calls that were made to FindUserByEmail.
// Check the length with:
//
//	len(mockedUserRepo.FindUserByEmailCalls())
func (mock *UserRepoMock) FindUserByEmailCalls() []struct {
	Ctx     context.Context
	Db      repository.Queryer
	E       string
	Columns []string
} {
	var calls []struct {
		Ctx     context.Context
		Db      repository.Queryer
		E       string
		Columns []string
	}
	mock.lockFindUserByEmail.RLock()
	calls = mock.calls.FindUserByEmail
	mock.lockFindUserByEmail.RUnlock()
	return calls
}

// GetAll calls GetAllFunc.
func (mock *UserRepoMock) GetAll(ctx context.Context, db repository.Queryer, columns ...string) ([]*entities.User, error) {
	if mock.GetAllFunc == nil {
		panic("UserRepoMock.GetAllFunc: method is nil but UserRepo.GetAll was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Db      repository.Queryer
		Columns []string
	}{
		Ctx:     ctx,
		Db:      db,
		Columns: columns,
	}
	mock.lockGetAll.Lock()
	mock.calls.GetAll = append(mock.calls.GetAll, callInfo)
	mock.lockGetAll.Unlock()
	return mock.GetAllFunc(ctx, db, columns...)
}

// GetAllCalls gets all the calls that were made to GetAll.
// Check the length with:
//
//	len(mockedUserRepo.GetAllCalls())
func (mock *UserRepoMock) GetAllCalls() []struct {
	Ctx     context.Context
	Db      repository.Queryer
	Columns []string
} {
	var calls []struct {
		Ctx     context.Context
		Db      repository.Queryer
		Columns []string
	}
	mock.lockGetAll.RLock()
	calls = mock.calls.GetAll
	mock.lockGetAll.RUnlock()
	return calls
}

// GetAllWithCursor calls GetAllOrderPointFunc.
func (mock *UserRepoMock) GetAllWithCursor(ctx context.Context, db repository.Queryer, param repository.GetAllWithCursorParam) ([]*entities.User, error) {
	if mock.GetAllOrderPointFunc == nil {
		panic("UserRepoMock.GetAllOrderPointFunc: method is nil but UserRepo.GetAllOrderPoint was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Db    repository.Queryer
		Param repository.GetAllWithCursorParam
	}{
		Ctx:   ctx,
		Db:    db,
		Param: param,
	}
	mock.lockGetAllOrderPoint.Lock()
	mock.calls.GetAllOrderPoint = append(mock.calls.GetAllOrderPoint, callInfo)
	mock.lockGetAllOrderPoint.Unlock()
	return mock.GetAllOrderPointFunc(ctx, db, param)
}

// GetAllOrderPointCalls gets all the calls that were made to GetAllOrderPoint.
// Check the length with:
//
//	len(mockedUserRepo.GetAllOrderPointCalls())
func (mock *UserRepoMock) GetAllOrderPointCalls() []struct {
	Ctx   context.Context
	Db    repository.Queryer
	Param repository.GetAllWithCursorParam
} {
	var calls []struct {
		Ctx   context.Context
		Db    repository.Queryer
		Param repository.GetAllWithCursorParam
	}
	mock.lockGetAllOrderPoint.RLock()
	calls = mock.calls.GetAllOrderPoint
	mock.lockGetAllOrderPoint.RUnlock()
	return calls
}

// GetUserByID calls GetUserByIDFunc.
func (mock *UserRepoMock) GetUserByID(ctx context.Context, db repository.Queryer, ID model.UserID) (entities.User, error) {
	if mock.GetUserByIDFunc == nil {
		panic("UserRepoMock.GetUserByIDFunc: method is nil but UserRepo.GetUserByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  repository.Queryer
		ID  model.UserID
	}{
		Ctx: ctx,
		Db:  db,
		ID:  ID,
	}
	mock.lockGetUserByID.Lock()
	mock.calls.GetUserByID = append(mock.calls.GetUserByID, callInfo)
	mock.lockGetUserByID.Unlock()
	return mock.GetUserByIDFunc(ctx, db, ID)
}

// GetUserByIDCalls gets all the calls that were made to GetUserByID.
// Check the length with:
//
//	len(mockedUserRepo.GetUserByIDCalls())
func (mock *UserRepoMock) GetUserByIDCalls() []struct {
	Ctx context.Context
	Db  repository.Queryer
	ID  model.UserID
} {
	var calls []struct {
		Ctx context.Context
		Db  repository.Queryer
		ID  model.UserID
	}
	mock.lockGetUserByID.RLock()
	calls = mock.calls.GetUserByID
	mock.lockGetUserByID.RUnlock()
	return calls
}

// GetUsers calls GetUsersLimitFunc.
func (mock *UserRepoMock) GetUsers(ctx context.Context, db repository.Queryer, param repository.GetUsersParam) ([]*entities.User, error) {
	if mock.GetUsersLimitFunc == nil {
		panic("UserRepoMock.GetUsersLimitFunc: method is nil but UserRepo.GetUsersLimit was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Db    repository.Queryer
		Param repository.GetUsersParam
	}{
		Ctx:   ctx,
		Db:    db,
		Param: param,
	}
	mock.lockGetUsersLimit.Lock()
	mock.calls.GetUsersLimit = append(mock.calls.GetUsersLimit, callInfo)
	mock.lockGetUsersLimit.Unlock()
	return mock.GetUsersLimitFunc(ctx, db, param)
}

// GetUsersLimitCalls gets all the calls that were made to GetUsersLimit.
// Check the length with:
//
//	len(mockedUserRepo.GetUsersLimitCalls())
func (mock *UserRepoMock) GetUsersLimitCalls() []struct {
	Ctx   context.Context
	Db    repository.Queryer
	Param repository.GetUsersParam
} {
	var calls []struct {
		Ctx   context.Context
		Db    repository.Queryer
		Param repository.GetUsersParam
	}
	mock.lockGetUsersLimit.RLock()
	calls = mock.calls.GetUsersLimit
	mock.lockGetUsersLimit.RUnlock()
	return calls
}

// RegisterUser calls RegisterUserFunc.
func (mock *UserRepoMock) RegisterUser(ctx context.Context, db repository.Execer, u *entities.User) error {
	if mock.RegisterUserFunc == nil {
		panic("UserRepoMock.RegisterUserFunc: method is nil but UserRepo.RegisterUser was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  repository.Execer
		U   *entities.User
	}{
		Ctx: ctx,
		Db:  db,
		U:   u,
	}
	mock.lockRegisterUser.Lock()
	mock.calls.RegisterUser = append(mock.calls.RegisterUser, callInfo)
	mock.lockRegisterUser.Unlock()
	return mock.RegisterUserFunc(ctx, db, u)
}

// RegisterUserCalls gets all the calls that were made to RegisterUser.
// Check the length with:
//
//	len(mockedUserRepo.RegisterUserCalls())
func (mock *UserRepoMock) RegisterUserCalls() []struct {
	Ctx context.Context
	Db  repository.Execer
	U   *entities.User
} {
	var calls []struct {
		Ctx context.Context
		Db  repository.Execer
		U   *entities.User
	}
	mock.lockRegisterUser.RLock()
	calls = mock.calls.RegisterUser
	mock.lockRegisterUser.RUnlock()
	return calls
}

// UpdateAccount calls UpdateAccountFunc.
func (mock *UserRepoMock) UpdateAccount(ctx context.Context, db repository.Execer, email *string, familyName *string, familyNameKana *string, firstName *string, firstNameKana *string) error {
	if mock.UpdateAccountFunc == nil {
		panic("UserRepoMock.UpdateAccountFunc: method is nil but UserRepo.UpdateAccount was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Db             repository.Execer
		Email          *string
		FamilyName     *string
		FamilyNameKana *string
		FirstName      *string
		FirstNameKana  *string
	}{
		Ctx:            ctx,
		Db:             db,
		Email:          email,
		FamilyName:     familyName,
		FamilyNameKana: familyNameKana,
		FirstName:      firstName,
		FirstNameKana:  firstNameKana,
	}
	mock.lockUpdateAccount.Lock()
	mock.calls.UpdateAccount = append(mock.calls.UpdateAccount, callInfo)
	mock.lockUpdateAccount.Unlock()
	return mock.UpdateAccountFunc(ctx, db, email, familyName, familyNameKana, firstName, firstNameKana)
}

// UpdateAccountCalls gets all the calls that were made to UpdateAccount.
// Check the length with:
//
//	len(mockedUserRepo.UpdateAccountCalls())
func (mock *UserRepoMock) UpdateAccountCalls() []struct {
	Ctx            context.Context
	Db             repository.Execer
	Email          *string
	FamilyName     *string
	FamilyNameKana *string
	FirstName      *string
	FirstNameKana  *string
} {
	var calls []struct {
		Ctx            context.Context
		Db             repository.Execer
		Email          *string
		FamilyName     *string
		FamilyNameKana *string
		FirstName      *string
		FirstNameKana  *string
	}
	mock.lockUpdateAccount.RLock()
	calls = mock.calls.UpdateAccount
	mock.lockUpdateAccount.RUnlock()
	return calls
}

// UpdateEmail calls UpdateEmailFunc.
func (mock *UserRepoMock) UpdateEmail(ctx context.Context, db repository.Execer, userID model.UserID, newEmail string) error {
	if mock.UpdateEmailFunc == nil {
		panic("UserRepoMock.UpdateEmailFunc: method is nil but UserRepo.UpdateEmail was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Db       repository.Execer
		UserID   model.UserID
		NewEmail string
	}{
		Ctx:      ctx,
		Db:       db,
		UserID:   userID,
		NewEmail: newEmail,
	}
	mock.lockUpdateEmail.Lock()
	mock.calls.UpdateEmail = append(mock.calls.UpdateEmail, callInfo)
	mock.lockUpdateEmail.Unlock()
	return mock.UpdateEmailFunc(ctx, db, userID, newEmail)
}

// UpdateEmailCalls gets all the calls that were made to UpdateEmail.
// Check the length with:
//
//	len(mockedUserRepo.UpdateEmailCalls())
func (mock *UserRepoMock) UpdateEmailCalls() []struct {
	Ctx      context.Context
	Db       repository.Execer
	UserID   model.UserID
	NewEmail string
} {
	var calls []struct {
		Ctx      context.Context
		Db       repository.Execer
		UserID   model.UserID
		NewEmail string
	}
	mock.lockUpdateEmail.RLock()
	calls = mock.calls.UpdateEmail
	mock.lockUpdateEmail.RUnlock()
	return calls
}

// UpdatePassword calls UpdatePasswordFunc.
func (mock *UserRepoMock) UpdatePassword(ctx context.Context, db repository.Execer, email *string, pass *string) error {
	if mock.UpdatePasswordFunc == nil {
		panic("UserRepoMock.UpdatePasswordFunc: method is nil but UserRepo.UpdatePassword was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Db    repository.Execer
		Email *string
		Pass  *string
	}{
		Ctx:   ctx,
		Db:    db,
		Email: email,
		Pass:  pass,
	}
	mock.lockUpdatePassword.Lock()
	mock.calls.UpdatePassword = append(mock.calls.UpdatePassword, callInfo)
	mock.lockUpdatePassword.Unlock()
	return mock.UpdatePasswordFunc(ctx, db, email, pass)
}

// UpdatePasswordCalls gets all the calls that were made to UpdatePassword.
// Check the length with:
//
//	len(mockedUserRepo.UpdatePasswordCalls())
func (mock *UserRepoMock) UpdatePasswordCalls() []struct {
	Ctx   context.Context
	Db    repository.Execer
	Email *string
	Pass  *string
} {
	var calls []struct {
		Ctx   context.Context
		Db    repository.Execer
		Email *string
		Pass  *string
	}
	mock.lockUpdatePassword.RLock()
	calls = mock.calls.UpdatePassword
	mock.lockUpdatePassword.RUnlock()
	return calls
}

// PointRepoMock is a mock implementation of domain.PointRepo.
//
//	func TestSomethingThatUsesPointRepo(t *testing.T) {
//
//		// make and configure a mocked domain.PointRepo
//		mockedPointRepo := &PointRepoMock{
//			RegisterPointTransactionFunc: func(ctx context.Context, db repository.Execer, fromUserID model.UserID, toUserId model.UserID, sendPoint int) error {
//				panic("mock out the RegisterPointTransaction method")
//			},
//			UpdateAllSendablePointFunc: func(ctx context.Context, db repository.Execer, point int) error {
//				panic("mock out the UpdateAllSendablePoint method")
//			},
//			UpdateSendablePointFunc: func(ctx context.Context, db repository.Execer, fromUserID model.UserID, sendPoint int) error {
//				panic("mock out the UpdateSendablePoint method")
//			},
//		}
//
//		// use mockedPointRepo in code that requires domain.PointRepo
//		// and then make assertions.
//
//	}
type PointRepoMock struct {
	// RegisterPointTransactionFunc mocks the RegisterPointTransaction method.
	RegisterPointTransactionFunc func(ctx context.Context, db repository.Execer, fromUserID model.UserID, toUserId model.UserID, sendPoint int) error

	// UpdateAllSendablePointFunc mocks the UpdateAllSendablePoint method.
	UpdateAllSendablePointFunc func(ctx context.Context, db repository.Execer, point int) error

	// UpdateSendablePointFunc mocks the UpdateSendablePoint method.
	UpdateSendablePointFunc func(ctx context.Context, db repository.Execer, fromUserID model.UserID, sendPoint int) error

	// calls tracks calls to the methods.
	calls struct {
		// RegisterPointTransaction holds details about calls to the RegisterPointTransaction method.
		RegisterPointTransaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Execer
			// FromUserID is the fromUserID argument value.
			FromUserID model.UserID
			// ToUserId is the toUserId argument value.
			ToUserId model.UserID
			// SendPoint is the sendPoint argument value.
			SendPoint int
		}
		// UpdateAllSendablePoint holds details about calls to the UpdateAllSendablePoint method.
		UpdateAllSendablePoint []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Execer
			// Point is the point argument value.
			Point int
		}
		// UpdateSendablePoint holds details about calls to the UpdateSendablePoint method.
		UpdateSendablePoint []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Execer
			// FromUserID is the fromUserID argument value.
			FromUserID model.UserID
			// SendPoint is the sendPoint argument value.
			SendPoint int
		}
	}
	lockRegisterPointTransaction sync.RWMutex
	lockUpdateAllSendablePoint   sync.RWMutex
	lockUpdateSendablePoint      sync.RWMutex
}

// RegisterPointTransaction calls RegisterPointTransactionFunc.
func (mock *PointRepoMock) RegisterPointTransaction(ctx context.Context, db repository.Execer, fromUserID model.UserID, toUserId model.UserID, sendPoint int) error {
	if mock.RegisterPointTransactionFunc == nil {
		panic("PointRepoMock.RegisterPointTransactionFunc: method is nil but PointRepo.RegisterPointTransaction was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Db         repository.Execer
		FromUserID model.UserID
		ToUserId   model.UserID
		SendPoint  int
	}{
		Ctx:        ctx,
		Db:         db,
		FromUserID: fromUserID,
		ToUserId:   toUserId,
		SendPoint:  sendPoint,
	}
	mock.lockRegisterPointTransaction.Lock()
	mock.calls.RegisterPointTransaction = append(mock.calls.RegisterPointTransaction, callInfo)
	mock.lockRegisterPointTransaction.Unlock()
	return mock.RegisterPointTransactionFunc(ctx, db, fromUserID, toUserId, sendPoint)
}

// RegisterPointTransactionCalls gets all the calls that were made to RegisterPointTransaction.
// Check the length with:
//
//	len(mockedPointRepo.RegisterPointTransactionCalls())
func (mock *PointRepoMock) RegisterPointTransactionCalls() []struct {
	Ctx        context.Context
	Db         repository.Execer
	FromUserID model.UserID
	ToUserId   model.UserID
	SendPoint  int
} {
	var calls []struct {
		Ctx        context.Context
		Db         repository.Execer
		FromUserID model.UserID
		ToUserId   model.UserID
		SendPoint  int
	}
	mock.lockRegisterPointTransaction.RLock()
	calls = mock.calls.RegisterPointTransaction
	mock.lockRegisterPointTransaction.RUnlock()
	return calls
}

// UpdateAllSendablePoint calls UpdateAllSendablePointFunc.
func (mock *PointRepoMock) UpdateAllSendablePoint(ctx context.Context, db repository.Execer, point int) error {
	if mock.UpdateAllSendablePointFunc == nil {
		panic("PointRepoMock.UpdateAllSendablePointFunc: method is nil but PointRepo.UpdateAllSendablePoint was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Db    repository.Execer
		Point int
	}{
		Ctx:   ctx,
		Db:    db,
		Point: point,
	}
	mock.lockUpdateAllSendablePoint.Lock()
	mock.calls.UpdateAllSendablePoint = append(mock.calls.UpdateAllSendablePoint, callInfo)
	mock.lockUpdateAllSendablePoint.Unlock()
	return mock.UpdateAllSendablePointFunc(ctx, db, point)
}

// UpdateAllSendablePointCalls gets all the calls that were made to UpdateAllSendablePoint.
// Check the length with:
//
//	len(mockedPointRepo.UpdateAllSendablePointCalls())
func (mock *PointRepoMock) UpdateAllSendablePointCalls() []struct {
	Ctx   context.Context
	Db    repository.Execer
	Point int
} {
	var calls []struct {
		Ctx   context.Context
		Db    repository.Execer
		Point int
	}
	mock.lockUpdateAllSendablePoint.RLock()
	calls = mock.calls.UpdateAllSendablePoint
	mock.lockUpdateAllSendablePoint.RUnlock()
	return calls
}

// UpdateSendablePoint calls UpdateSendablePointFunc.
func (mock *PointRepoMock) UpdateSendablePoint(ctx context.Context, db repository.Execer, fromUserID model.UserID, sendPoint int) error {
	if mock.UpdateSendablePointFunc == nil {
		panic("PointRepoMock.UpdateSendablePointFunc: method is nil but PointRepo.UpdateSendablePoint was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Db         repository.Execer
		FromUserID model.UserID
		SendPoint  int
	}{
		Ctx:        ctx,
		Db:         db,
		FromUserID: fromUserID,
		SendPoint:  sendPoint,
	}
	mock.lockUpdateSendablePoint.Lock()
	mock.calls.UpdateSendablePoint = append(mock.calls.UpdateSendablePoint, callInfo)
	mock.lockUpdateSendablePoint.Unlock()
	return mock.UpdateSendablePointFunc(ctx, db, fromUserID, sendPoint)
}

// UpdateSendablePointCalls gets all the calls that were made to UpdateSendablePoint.
// Check the length with:
//
//	len(mockedPointRepo.UpdateSendablePointCalls())
func (mock *PointRepoMock) UpdateSendablePointCalls() []struct {
	Ctx        context.Context
	Db         repository.Execer
	FromUserID model.UserID
	SendPoint  int
} {
	var calls []struct {
		Ctx        context.Context
		Db         repository.Execer
		FromUserID model.UserID
		SendPoint  int
	}
	mock.lockUpdateSendablePoint.RLock()
	calls = mock.calls.UpdateSendablePoint
	mock.lockUpdateSendablePoint.RUnlock()
	return calls
}

// NotificationRepoMock is a mock implementation of domain.NotificationRepo.
//
//	func TestSomethingThatUsesNotificationRepo(t *testing.T) {
//
//		// make and configure a mocked domain.NotificationRepo
//		mockedNotificationRepo := &NotificationRepoMock{
//			CheckNotificationFunc: func(ctx context.Context, db repository.Execer, uid model.UserID, nid model.NotificationID) error {
//				panic("mock out the CheckNotification method")
//			},
//			CreateNotificationFunc: func(ctx context.Context, db repository.Execer, notification customentities.Notification) (customentities.Notification, error) {
//				panic("mock out the CreateNotification method")
//			},
//			GetByToUserByStartIdOrderByLatestFunc: func(ctx context.Context, db repository.Queryer, uid model.UserID, startID model.NotificationID, size int, columns ...string) ([]*customentities.Notification, error) {
//				panic("mock out the GetByToUserByStartIdOrderByLatest method")
//			},
//			GetByToUserOrderByLatestFunc: func(ctx context.Context, db repository.Queryer, uid model.UserID, size int, columns ...string) ([]*customentities.Notification, error) {
//				panic("mock out the GetByToUserOrderByLatest method")
//			},
//			GetNotificationByIDFunc: func(ctx context.Context, db repository.Queryer, uid model.UserID, nid model.NotificationID) (customentities.Notification, error) {
//				panic("mock out the GetNotificationByID method")
//			},
//			GetUncheckedNotificationCountFunc: func(ctx context.Context, db repository.Queryer, uid model.UserID) (int, error) {
//				panic("mock out the GetUncheckedNotificationCount method")
//			},
//		}
//
//		// use mockedNotificationRepo in code that requires domain.NotificationRepo
//		// and then make assertions.
//
//	}
type NotificationRepoMock struct {
	// CheckNotificationFunc mocks the CheckNotification method.
	CheckNotificationFunc func(ctx context.Context, db repository.Execer, uid model.UserID, nid model.NotificationID) error

	// CreateNotificationFunc mocks the CreateNotification method.
	CreateNotificationFunc func(ctx context.Context, db repository.Execer, notification customentities.Notification) (customentities.Notification, error)

	// GetByToUserByStartIdOrderByLatestFunc mocks the GetByToUserByStartIdOrderByLatest method.
	GetByToUserByStartIdOrderByLatestFunc func(ctx context.Context, db repository.Queryer, uid model.UserID, startID model.NotificationID, size int, columns ...string) ([]*customentities.Notification, error)

	// GetByToUserOrderByLatestFunc mocks the GetByToUserOrderByLatest method.
	GetByToUserOrderByLatestFunc func(ctx context.Context, db repository.Queryer, uid model.UserID, size int, columns ...string) ([]*customentities.Notification, error)

	// GetNotificationByIDFunc mocks the GetNotificationByID method.
	GetNotificationByIDFunc func(ctx context.Context, db repository.Queryer, uid model.UserID, nid model.NotificationID) (customentities.Notification, error)

	// GetUncheckedNotificationCountFunc mocks the GetUncheckedNotificationCount method.
	GetUncheckedNotificationCountFunc func(ctx context.Context, db repository.Queryer, uid model.UserID) (int, error)

	// calls tracks calls to the methods.
	calls struct {
		// CheckNotification holds details about calls to the CheckNotification method.
		CheckNotification []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Execer
			// UID is the uid argument value.
			UID model.UserID
			// Nid is the nid argument value.
			Nid model.NotificationID
		}
		// CreateNotification holds details about calls to the CreateNotification method.
		CreateNotification []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Execer
			// Notification is the notification argument value.
			Notification customentities.Notification
		}
		// GetByToUserByStartIdOrderByLatest holds details about calls to the GetByToUserByStartIdOrderByLatest method.
		GetByToUserByStartIdOrderByLatest []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Queryer
			// UID is the uid argument value.
			UID model.UserID
			// StartID is the startID argument value.
			StartID model.NotificationID
			// Size is the size argument value.
			Size int
			// Columns is the columns argument value.
			Columns []string
		}
		// GetByToUserOrderByLatest holds details about calls to the GetByToUserOrderByLatest method.
		GetByToUserOrderByLatest []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Queryer
			// UID is the uid argument value.
			UID model.UserID
			// Size is the size argument value.
			Size int
			// Columns is the columns argument value.
			Columns []string
		}
		// GetNotificationByID holds details about calls to the GetNotificationByID method.
		GetNotificationByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Queryer
			// UID is the uid argument value.
			UID model.UserID
			// Nid is the nid argument value.
			Nid model.NotificationID
		}
		// GetUncheckedNotificationCount holds details about calls to the GetUncheckedNotificationCount method.
		GetUncheckedNotificationCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db repository.Queryer
			// UID is the uid argument value.
			UID model.UserID
		}
	}
	lockCheckNotification                 sync.RWMutex
	lockCreateNotification                sync.RWMutex
	lockGetByToUserByStartIdOrderByLatest sync.RWMutex
	lockGetByToUserOrderByLatest          sync.RWMutex
	lockGetNotificationByID               sync.RWMutex
	lockGetUncheckedNotificationCount     sync.RWMutex
}

// CheckNotification calls CheckNotificationFunc.
func (mock *NotificationRepoMock) CheckNotification(ctx context.Context, db repository.Execer, uid model.UserID, nid model.NotificationID) error {
	if mock.CheckNotificationFunc == nil {
		panic("NotificationRepoMock.CheckNotificationFunc: method is nil but NotificationRepo.CheckNotification was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  repository.Execer
		UID model.UserID
		Nid model.NotificationID
	}{
		Ctx: ctx,
		Db:  db,
		UID: uid,
		Nid: nid,
	}
	mock.lockCheckNotification.Lock()
	mock.calls.CheckNotification = append(mock.calls.CheckNotification, callInfo)
	mock.lockCheckNotification.Unlock()
	return mock.CheckNotificationFunc(ctx, db, uid, nid)
}

// CheckNotificationCalls gets all the calls that were made to CheckNotification.
// Check the length with:
//
//	len(mockedNotificationRepo.CheckNotificationCalls())
func (mock *NotificationRepoMock) CheckNotificationCalls() []struct {
	Ctx context.Context
	Db  repository.Execer
	UID model.UserID
	Nid model.NotificationID
} {
	var calls []struct {
		Ctx context.Context
		Db  repository.Execer
		UID model.UserID
		Nid model.NotificationID
	}
	mock.lockCheckNotification.RLock()
	calls = mock.calls.CheckNotification
	mock.lockCheckNotification.RUnlock()
	return calls
}

// CreateNotification calls CreateNotificationFunc.
func (mock *NotificationRepoMock) CreateNotification(ctx context.Context, db repository.Execer, notification customentities.Notification) (customentities.Notification, error) {
	if mock.CreateNotificationFunc == nil {
		panic("NotificationRepoMock.CreateNotificationFunc: method is nil but NotificationRepo.CreateNotification was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		Db           repository.Execer
		Notification customentities.Notification
	}{
		Ctx:          ctx,
		Db:           db,
		Notification: notification,
	}
	mock.lockCreateNotification.Lock()
	mock.calls.CreateNotification = append(mock.calls.CreateNotification, callInfo)
	mock.lockCreateNotification.Unlock()
	return mock.CreateNotificationFunc(ctx, db, notification)
}

// CreateNotificationCalls gets all the calls that were made to CreateNotification.
// Check the length with:
//
//	len(mockedNotificationRepo.CreateNotificationCalls())
func (mock *NotificationRepoMock) CreateNotificationCalls() []struct {
	Ctx          context.Context
	Db           repository.Execer
	Notification customentities.Notification
} {
	var calls []struct {
		Ctx          context.Context
		Db           repository.Execer
		Notification customentities.Notification
	}
	mock.lockCreateNotification.RLock()
	calls = mock.calls.CreateNotification
	mock.lockCreateNotification.RUnlock()
	return calls
}

// GetByToUserByStartIdOrderByLatest calls GetByToUserByStartIdOrderByLatestFunc.
func (mock *NotificationRepoMock) GetByToUserByStartIdOrderByLatest(ctx context.Context, db repository.Queryer, uid model.UserID, startID model.NotificationID, size int, columns ...string) ([]*customentities.Notification, error) {
	if mock.GetByToUserByStartIdOrderByLatestFunc == nil {
		panic("NotificationRepoMock.GetByToUserByStartIdOrderByLatestFunc: method is nil but NotificationRepo.GetByToUserByStartIdOrderByLatest was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Db      repository.Queryer
		UID     model.UserID
		StartID model.NotificationID
		Size    int
		Columns []string
	}{
		Ctx:     ctx,
		Db:      db,
		UID:     uid,
		StartID: startID,
		Size:    size,
		Columns: columns,
	}
	mock.lockGetByToUserByStartIdOrderByLatest.Lock()
	mock.calls.GetByToUserByStartIdOrderByLatest = append(mock.calls.GetByToUserByStartIdOrderByLatest, callInfo)
	mock.lockGetByToUserByStartIdOrderByLatest.Unlock()
	return mock.GetByToUserByStartIdOrderByLatestFunc(ctx, db, uid, startID, size, columns...)
}

// GetByToUserByStartIdOrderByLatestCalls gets all the calls that were made to GetByToUserByStartIdOrderByLatest.
// Check the length with:
//
//	len(mockedNotificationRepo.GetByToUserByStartIdOrderByLatestCalls())
func (mock *NotificationRepoMock) GetByToUserByStartIdOrderByLatestCalls() []struct {
	Ctx     context.Context
	Db      repository.Queryer
	UID     model.UserID
	StartID model.NotificationID
	Size    int
	Columns []string
} {
	var calls []struct {
		Ctx     context.Context
		Db      repository.Queryer
		UID     model.UserID
		StartID model.NotificationID
		Size    int
		Columns []string
	}
	mock.lockGetByToUserByStartIdOrderByLatest.RLock()
	calls = mock.calls.GetByToUserByStartIdOrderByLatest
	mock.lockGetByToUserByStartIdOrderByLatest.RUnlock()
	return calls
}

// GetByToUserOrderByLatest calls GetByToUserOrderByLatestFunc.
func (mock *NotificationRepoMock) GetByToUserOrderByLatest(ctx context.Context, db repository.Queryer, uid model.UserID, size int, columns ...string) ([]*customentities.Notification, error) {
	if mock.GetByToUserOrderByLatestFunc == nil {
		panic("NotificationRepoMock.GetByToUserOrderByLatestFunc: method is nil but NotificationRepo.GetByToUserOrderByLatest was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Db      repository.Queryer
		UID     model.UserID
		Size    int
		Columns []string
	}{
		Ctx:     ctx,
		Db:      db,
		UID:     uid,
		Size:    size,
		Columns: columns,
	}
	mock.lockGetByToUserOrderByLatest.Lock()
	mock.calls.GetByToUserOrderByLatest = append(mock.calls.GetByToUserOrderByLatest, callInfo)
	mock.lockGetByToUserOrderByLatest.Unlock()
	return mock.GetByToUserOrderByLatestFunc(ctx, db, uid, size, columns...)
}

// GetByToUserOrderByLatestCalls gets all the calls that were made to GetByToUserOrderByLatest.
// Check the length with:
//
//	len(mockedNotificationRepo.GetByToUserOrderByLatestCalls())
func (mock *NotificationRepoMock) GetByToUserOrderByLatestCalls() []struct {
	Ctx     context.Context
	Db      repository.Queryer
	UID     model.UserID
	Size    int
	Columns []string
} {
	var calls []struct {
		Ctx     context.Context
		Db      repository.Queryer
		UID     model.UserID
		Size    int
		Columns []string
	}
	mock.lockGetByToUserOrderByLatest.RLock()
	calls = mock.calls.GetByToUserOrderByLatest
	mock.lockGetByToUserOrderByLatest.RUnlock()
	return calls
}

// GetNotificationByID calls GetNotificationByIDFunc.
func (mock *NotificationRepoMock) GetNotificationByID(ctx context.Context, db repository.Queryer, uid model.UserID, nid model.NotificationID) (customentities.Notification, error) {
	if mock.GetNotificationByIDFunc == nil {
		panic("NotificationRepoMock.GetNotificationByIDFunc: method is nil but NotificationRepo.GetNotificationByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  repository.Queryer
		UID model.UserID
		Nid model.NotificationID
	}{
		Ctx: ctx,
		Db:  db,
		UID: uid,
		Nid: nid,
	}
	mock.lockGetNotificationByID.Lock()
	mock.calls.GetNotificationByID = append(mock.calls.GetNotificationByID, callInfo)
	mock.lockGetNotificationByID.Unlock()
	return mock.GetNotificationByIDFunc(ctx, db, uid, nid)
}

// GetNotificationByIDCalls gets all the calls that were made to GetNotificationByID.
// Check the length with:
//
//	len(mockedNotificationRepo.GetNotificationByIDCalls())
func (mock *NotificationRepoMock) GetNotificationByIDCalls() []struct {
	Ctx context.Context
	Db  repository.Queryer
	UID model.UserID
	Nid model.NotificationID
} {
	var calls []struct {
		Ctx context.Context
		Db  repository.Queryer
		UID model.UserID
		Nid model.NotificationID
	}
	mock.lockGetNotificationByID.RLock()
	calls = mock.calls.GetNotificationByID
	mock.lockGetNotificationByID.RUnlock()
	return calls
}

// GetUncheckedNotificationCount calls GetUncheckedNotificationCountFunc.
func (mock *NotificationRepoMock) GetUncheckedNotificationCount(ctx context.Context, db repository.Queryer, uid model.UserID) (int, error) {
	if mock.GetUncheckedNotificationCountFunc == nil {
		panic("NotificationRepoMock.GetUncheckedNotificationCountFunc: method is nil but NotificationRepo.GetUncheckedNotificationCount was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  repository.Queryer
		UID model.UserID
	}{
		Ctx: ctx,
		Db:  db,
		UID: uid,
	}
	mock.lockGetUncheckedNotificationCount.Lock()
	mock.calls.GetUncheckedNotificationCount = append(mock.calls.GetUncheckedNotificationCount, callInfo)
	mock.lockGetUncheckedNotificationCount.Unlock()
	return mock.GetUncheckedNotificationCountFunc(ctx, db, uid)
}

// GetUncheckedNotificationCountCalls gets all the calls that were made to GetUncheckedNotificationCount.
// Check the length with:
//
//	len(mockedNotificationRepo.GetUncheckedNotificationCountCalls())
func (mock *NotificationRepoMock) GetUncheckedNotificationCountCalls() []struct {
	Ctx context.Context
	Db  repository.Queryer
	UID model.UserID
} {
	var calls []struct {
		Ctx context.Context
		Db  repository.Queryer
		UID model.UserID
	}
	mock.lockGetUncheckedNotificationCount.RLock()
	calls = mock.calls.GetUncheckedNotificationCount
	mock.lockGetUncheckedNotificationCount.RUnlock()
	return calls
}
